# Тестовое задание для Saber Interactive
## Задание 1:
> Реализуйте функции сериализации и десериализации двусвязного списка, заданного следующим образом:

```csharp
class ListNode
{
    public ListNode Prev;
    public ListNode Next;
    public ListNode Rand; // произвольный элемент внутри списка
    public string Data;
}
class ListRand
{
    public ListNode Head;
    public ListNode Tail;
    public int Count;

    public void Serialize(FileStream s)
    {
    }

    public void Deserialize(FileStream s)
    {
    }
}
```
Примечание: сериализация подразумевает сохранение и восстановление полной структуры списка, включая взаимное соотношение его элементов между собой — в том числе ссылок на Rand элементы.

**Алгоритмическая сложность решения должна быть меньше квадратичной.**

**Нельзя изменять исходную структуру классов ListNode, ListRand.**

Для выполнения задания можно использовать любой общеиспользуемый язык.

Тест нужно выполнить без использования библиотек/стандартных средств сериализации.

## Задание 2:
> Напишите ИИ для противника используя BhvTree (достаточно нарисовать схему, реализация в
каком-либо из движков не требуется).

Солдат - сущность, которая может стрелять, перезаряжаться, отправиться в указанную точку и ждать.
- Солдат проводит патруль по зацикленному маршруту по точкам А и Б
- По прибытии на точку солдат останавливается на 10 минут в ожидании врага.
- Если за 10 минут враг не появился, солдат идет на следующую точку.
- Если враг обнаружен (на любой дистанции), солдат производит 10 выстрелов с паузой 5 секунд между каждым.
- Если враг убит или произведено 10 выстрелов, солдат отправляется в следующую точку

------------
### **Решение**


![Tree](https://user-images.githubusercontent.com/108364849/213845301-278e4c9a-c4fd-4dca-b05c-20ecff80e43d.JPG)

Дерево состоит из простых узлов, приближенных по смыслу к узлам BehaviourTree Unreal Engine. Справа показаны все виды задействованных узлов, а также их тип.

В узлах типа **Condition** проводится проверка на те условия, которыми подписаны узла такого типа. В случае возврата значения **true** вышестоящему узлу **Sequence** выполняться будет соседний узел справа. Если вышестоящий узел будет **Decorator**, то значение **true** будет изменено в соответствии с подписью этого узла.

Узел **Selector** работает стандартно, по очереди задействуя нижестоящие узлы слева направо.

В данной схеме узел **Decorator** необходим для продолжения действия вышестоящего узла **Sequence**, инвертируя значение от нижестоящего узла.
